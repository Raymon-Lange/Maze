import pygame
import sys, os
import random, time
from backTrackingGen import BackTrackingGen
from backTrackingSolve import backTrackingSolve
from TremauxsSolve import TremauxsSolve


class MazeSolver:
    def __init__(self):
        # Define maze dimensions and cell size
        self.mazeWidth = 50
        self.mazeHeight = 50
        self.cellSize = 7

        # Define maze matrix (0 for walls, 1 for open paths)
        self.maze = [[0 for _ in range(self.mazeWidth)] for _ in range(self.mazeHeight)]
        self.displayMaze = [[0 for _ in range(self.mazeWidth)] for _ in range(self.mazeHeight)]

        self.endPos = (0,0)
        self.startPos = (0,0)

        # Initialize Pygame
        pygame.init()

        # Create the screen
        self.screen = pygame.display.set_mode((self.mazeWidth * self.cellSize, self.mazeHeight * self.cellSize))
        pygame.display.set_caption("Maze Solver")

        # Define colors
        self.white = (255, 255, 255)
        self.start = (244, 3, 252)
        self.end = (173, 255, 47)
        self.path = (255, 204, 203)
        self.black = (0, 0, 0)

        # Define State for the maze program
        self.BUILD = 0
        self.END = 1
        self.SOLVE = 2
        self.DRAW = 3
        self.PAUSE = 4
        self.currentState = self.BUILD

        self.loadAssets()

    def resetMaze(self):
        self.maze = [[0 for _ in range(self.mazeWidth)] for _ in range(self.mazeHeight)]
        self.displayMaze = [[0 for _ in range(self.mazeWidth)] for _ in range(self.mazeHeight)]


    def drawMaze(self):
        for y in range(self.mazeHeight):
            for x in range(self.mazeWidth):
                if self.displayMaze[x][y] == 0:
                    pygame.draw.rect(self.screen, self.black, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))
                elif self.displayMaze[x][y] == 2:
                    pygame.draw.rect(self.screen, self.start, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))
                elif self.displayMaze[x][y] == 3:
                    pygame.draw.rect(self.screen, self.end, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))
                elif self.displayMaze[x][y] == 4:
                    pygame.draw.rect(self.screen, self.path, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))
                else:
                    pygame.draw.rect(self.screen, self.white, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))

        x = self.startPos[0]
        y = self.startPos[1]
        pygame.draw.rect(self.screen, self.start, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))

        x = self.endPos[0]
        y = self.endPos[1]
        pygame.draw.rect(self.screen, self.end, (x * self.cellSize, y * self.cellSize, self.cellSize, self.cellSize))


    def creatStartAndEnd(self):
        found = False
        while not found :
            pX = random.randrange(int(self.mazeHeight/2), self.mazeHeight)
            pY = random.randrange(int(self.mazeWidth/2), self.mazeWidth)

            if self.maze[pX][pY] == 1:
                self.endPos = (pX, pY)
                found = True

        found = False
        while not found :
            pX = random.randrange(1, int(self.mazeHeight/2))
            pY = random.randrange(1, int(self.mazeWidth/2))

            if self.maze[pX][pY] == 1:
                self.startPos = (pX, pY)
                found = True

    def drawMenu(self):
        pygame.draw.rect(self.screen, self.black, pygame.Rect(20, 20, 300, 300),  2, 10)
        pygame.draw.rect(self.screen, self.white, pygame.Rect(20, 20, 298, 298))

        self.drawText(self.screen, "Generation: \n Back tracking ", self.black, 150,40)

        self.drawText(self.screen, "Solving  \n Tremauxs ", self.black, 110,80)

        cells = f'Cells explored \n{self.explored}'
        self.drawText(self.screen, cells, self.black ,150, 120)

        cells = f'Shortest path \n{self.shortestPath}'
        self.drawText(self.screen, cells, self.black ,140, 170)

    def drawText(self, surface, text, color, x, y):
            text_surface = self.font.render(text, True, color)
            text_rect = text_surface.get_rect()
            text_rect.center = (x, y)
            surface.blit(text_surface, text_rect)

    def loadAssets(self):
        # Create pointers to directories 
        self.assets_dir = os.path.join("assets")
        self.font_dir = os.path.join(self.assets_dir, "font")
        self.font= pygame.font.Font(os.path.join(self.font_dir, "PressStart2P-vaV7.ttf"), 16)
    
    def main(self):

        # Generate the maze just once
        gen = BackTrackingGen(self.mazeHeight, self.mazeWidth)
    
        steps = gen.generate(self.maze)
        steps.reverse()

        self.creatStartAndEnd()

        solve = TremauxsSolve(self.maze)
        pathFound = solve.solve(self.startPos, self.endPos)
        path = solve.path
        wasHere = solve.wasHere
        wasHere.reverse()

        self.explored =  len(wasHere)
        self.shortestPath = len(path)

        count = 100000

        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            # Clear the screen
            self.screen.fill(self.black)

            if len(steps) > 0:
                step = steps.pop()
                self.displayMaze[step[0]][step[1]] = 1
            elif len(wasHere) > 0:
                step = wasHere.pop()
                self.displayMaze[step[0]][step[1]] = 4
            elif len(path) > 0:
                step = path.pop()
                self.displayMaze[step[0]][step[1]] = 3
            elif count > 0:
                count -= 1
                self.currentState = self.END
            else:
                running = False
                time.sleep(1)
                self.resetMaze()
                steps = gen.generate(self.maze)

                self.creatStartAndEnd()
                solve = backTrackingSolve(self.maze)
                pathFound = solve.solve(self.startPos, self.endPos)
                path = solve.path
                wasHere = solve.wasHere
                wasHere.reverse()
                self.explored =  len(wasHere)
                self.shortestPath = len(path)

                self.currentState = self.BUILD
                count = 1000
    
            # Draw the maze
            self.drawMaze()

            if self.currentState == self.END:
                pass
                #self.drawMenu()

            # Update the display
            pygame.display.flip()

        # Quit Pygame
        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    maze_solver = MazeSolver()
    maze_solver.main()
